<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">

<script>
    (function(){
        if(''){
            if (prompt('请输入密码') !== ''){
                alert('密码错误');
                history.back();
            }
        }
    })();
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="LoneyCao" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="引子假如有两个程序A和B，程序A在执行到一半的过程中，需要读取大量的数据输入（I&#x2F;O操作），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。是不是在程序A读取数据的过程中，让程序B去执行，当程序A读取完数据之后，让程序B暂停，然后让程序A继续执行？当然没问题，但这里有一个关键词：切换。既然是切换，那么这就涉及到了状态的保存，状态的恢复，加上程序A与程序B所需要的">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python-- 进程、线程、协程">
<meta property="og:url" content="http:&#x2F;&#x2F;loney-cao.github.io&#x2F;2019&#x2F;12&#x2F;23&#x2F;python_10&#x2F;index.html">
<meta property="og:site_name" content="LoneyCao">
<meta property="og:description" content="引子假如有两个程序A和B，程序A在执行到一半的过程中，需要读取大量的数据输入（I&#x2F;O操作），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。是不是在程序A读取数据的过程中，让程序B去执行，当程序A读取完数据之后，让程序B暂停，然后让程序A继续执行？当然没问题，但这里有一个关键词：切换。既然是切换，那么这就涉及到了状态的保存，状态的恢复，加上程序A与程序B所需要的">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-24T08:06:18.000Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://loney-cao.github.io/2019/12/23/python_10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Python-- 进程、线程、协程 | LoneyCao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LoneyCao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">即使一个人，也要活得像军队一样！</h1>
      
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=32405683&auto=1&height=66"></iframe>

  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-pictures">

    <a href="/categories/image/" rel="section"><i class="fa fa-fw fa-image"></i>图片</a>

  </li>
        <li class="menu-item menu-item-technologys">

    <a href="/categories/technology/" rel="section"><i class="fa fa-fw fa-code"></i>技术</a>

  </li>
        <li class="menu-item menu-item-farmercodethings">

    <a href="/categories/FarmerCodeThings/" rel="section"><i class="fa fa-fw fa-code"></i>程序员那些事儿</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-fw fa-link"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Loney-Cao" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://loney-cao.github.io/2019/12/23/python_10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LoneyCao">
      <meta itemprop="description" content="专注Odoo知识领域">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LoneyCao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Python-- 进程、线程、协程
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-23 22:18:12" itemprop="dateCreated datePublished" datetime="2019-12-23T22:18:12+08:00">2019-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-24 16:06:18" itemprop="dateModified" datetime="2019-12-24T16:06:18+08:00">2019-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/23/python_10/" class="post-meta-item leancloud_visitors" data-flag-title="Python-- 进程、线程、协程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/23/python_10/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/23/python_10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>假如有两个程序A和B，程序A在执行到一半的过程中，需要读取大量的数据输入（I/O操作），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。是不是在程序A读取数据的过程中，让程序B去执行，当程序A读取完数据之后，让程序B暂停，然后让程序A继续执行？当然没问题，但这里有一个关键词：切换。既然是切换，那么这就涉及到了状态的保存，状态的恢复，加上程序A与程序B所需要的系统资源（内存，硬盘，键盘等等）是不一样的。自然而然的就需要有一个东西去记录程序A和程序B分别需要什么资源，怎样去识别程序A和程序B等等，所以就有了一个叫进程的抽象</p><a id="more"></a>
<h2 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h2><p>进程就是一个程序在一个数据集上的一次动态执行过程。<br>进程一般由程序、数据集、进程控制块三部分组成。<br>我们编写的程序用来描述进程要完成哪些功能以及如何完成；<br>数据集则是程序在执行过程中所需要使用的资源；<br>进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程的出现是为了降低上下文切换的消耗，提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内并发成为可能。</strong></p>
<p>举例：<br>假设，一个文本程序，需要接受键盘输入，将内容显示在屏幕上，还需要保存信息到硬盘中。若只有 一个进程，势必造成同一时间只能干一样事的尴尬（当保存时，就不能通过键盘输入内容）。若有多个进程，每个进程负责一个任务，进程A负责接收键盘输入的任务，进程B负责将内容显示在屏幕上的任务，进程C负责保存内容到硬盘中的任务。这里进程A，B，C间的协作涉及到了进程通信问题，而且有<strong>共同都需要</strong>拥有的东西——-文本内容，不停的切换造成性能上的损失。<br>若有一种机制，<strong>可以使任务A，B，C共享资源，这样上下文切换所需要保存和恢复的内容就少了，同时又可以减少通信所带来的性能损耗</strong>，那就好了。是的，这种机制就是线程。</p>
<p><strong>线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。线程没有自己的系统资源。</strong></p>
<h2 id="线程进程的关系区别"><a href="#线程进程的关系区别" class="headerlink" title="线程进程的关系区别"></a>线程进程的关系区别</h2><p>1 一个程序至少有一个进程,一个进程至少有一个线程.(进程可以理解成线程的容器)</p>
<p>2 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>3 线程在执行过程中与进程还是有区别的。<strong>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口</strong>。<br>  但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>4 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调<br>  度的一个独立单位.<br>  线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程<br>  自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)但是<br>  它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>  一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>举一个不是很形象的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">银行有4个窗口， 每个窗口都可以存钱和取钱。4个窗口，也就限制了。同一时段，最多只能有4个客户在窗口进行存钱或取钱的操作。</span><br><span class="line"></span><br><span class="line">                窗口1     窗口2     窗口3      窗口4  </span><br><span class="line">                 存        取        存         取</span><br><span class="line"></span><br><span class="line">假如，存钱和取钱都是需要时间的。A准备存1个亿的现金，在A准备的过程中（A点钞或者专门有点钞的人员）B要取钱。此时B就可以在柜台取钱。而不耽误B的时间。</span><br><span class="line"></span><br><span class="line">                窗 口 1      窗 口 2     窗 口 3      窗 口 4  </span><br><span class="line">                存 | 取      存 | 取     存 | 取      存 | 取</span><br><span class="line"></span><br><span class="line">现在也就是说，同一时段，理想状态最多有8个客户在窗口进行存钱或取钱。</span><br></pre></td></tr></table></figure>

<p>何谓进程，何谓线程，我想你应该能够理清楚了。</p>
<h2 id="Python-的-GIL"><a href="#Python-的-GIL" class="headerlink" title="Python 的 GIL"></a>Python 的 GIL</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的核心意思就是，无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行</span></span><br></pre></td></tr></table></figure>

<p>Python中的线程是操作系统的原生线程，Python虚拟机使用一个全局解释器锁（Global Interpreter Lock）来互斥线程对Python虚拟机的使用。为了支持多线程机制，一个基本的要求就是需要实现不同线程对共享资源访问的互斥，所以引入了GIL。<br>GIL：在一个线程拥有了解释器的访问权之后，其他的所有线程都必须等待它释放解释器的访问权，即使这些线程的下一条指令并不会互相影响。<br>在调用任何Python C API之前，要先获得GIL<br>GIL缺点：多处理器退化为单处理器；优点：避免大量的加锁解锁操作</p>
<h2 id="python的线程与threading模块"><a href="#python的线程与threading模块" class="headerlink" title="python的线程与threading模块"></a>python的线程与threading模块</h2><h3 id="线程的两种调用方式"><a href="#线程的两种调用方式" class="headerlink" title="线程的两种调用方式"></a>线程的两种调用方式</h3><p>threading 模块建立在thread 模块之上。thread模块以低级、原始的方式来处理和控制线程，而threading 模块通过对thread进行二次封装，提供了更方便的api来处理线程。<br>直接调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(num)</span>:</span>  <span class="comment"># 定义每个线程要运行的函数</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"running on number:%s"</span> % num, <span class="string">"time--&gt;"</span>, time.time())</span><br><span class="line">    time.sleep(num)</span><br><span class="line">    print(<span class="string">"stop on number:%s"</span> % num, <span class="string">"time--&gt;"</span>, time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = threading.Thread(target=sayhi, args=(<span class="number">1</span>,))  <span class="comment"># 生成一个线程实例</span></span><br><span class="line">    t2 = threading.Thread(target=sayhi, args=(<span class="number">2</span>,))  <span class="comment"># 生成另一个线程实例</span></span><br><span class="line">    t1.start()  <span class="comment"># 启动线程</span></span><br><span class="line">    t2.start()  <span class="comment"># 启动另一个线程</span></span><br><span class="line">    print(<span class="string">"now time--&gt;"</span>, time.time())</span><br><span class="line">    print(<span class="string">'线程1--》》'</span>, t1.getName())  <span class="comment"># 获取线程名</span></span><br><span class="line">    print(<span class="string">'线程2--》》'</span>, t2.getName())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># running on number:1 time--&gt; 1577152259.8146904</span></span><br><span class="line"><span class="comment"># running on number:2 time--&gt; 1577152259.8146904</span></span><br><span class="line"><span class="comment"># now time--&gt; 1577152259.8146904</span></span><br><span class="line"><span class="comment"># 线程1--》》 Thread-1</span></span><br><span class="line"><span class="comment"># 线程2--》》 Thread-2</span></span><br><span class="line"><span class="comment"># stop on number:1 time--&gt; 1577152260.815012</span></span><br><span class="line"><span class="comment"># stop on number:2 time--&gt; 1577152261.815092</span></span><br></pre></td></tr></table></figure>

<p>继承调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  <span class="comment"># 定义每个线程要运行的函数</span></span><br><span class="line">        print(<span class="string">"running on number:%s"</span> % self.num, <span class="string">"time--&gt;"</span>, time.time())</span><br><span class="line">        time.sleep(self.num)</span><br><span class="line">        print(<span class="string">"stop on number:%s"</span> % self.num, <span class="string">"time--&gt;"</span>, time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    t1 = MyThread(<span class="number">1</span>)  <span class="comment"># 生成一个线程实例</span></span><br><span class="line">    t2 = MyThread(<span class="number">2</span>)  <span class="comment"># 生成另一个线程实例</span></span><br><span class="line">    t1.start()  <span class="comment"># 启动线程</span></span><br><span class="line">    t2.start()  <span class="comment"># 启动另一个线程</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"now time--&gt;"</span>, time.time())</span><br><span class="line">    print(<span class="string">'线程1--》》'</span>, t1.getName())  <span class="comment"># 获取线程名</span></span><br><span class="line">    print(<span class="string">'线程2--》》'</span>, t2.getName())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># running on number:1 time--&gt; 1577155042.4301505</span></span><br><span class="line"><span class="comment"># running on number:2 time--&gt; 1577155042.4301505</span></span><br><span class="line"><span class="comment"># now time--&gt; 1577155042.4301505</span></span><br><span class="line"><span class="comment"># 线程1--》》 Thread-1</span></span><br><span class="line"><span class="comment"># 线程2--》》 Thread-2</span></span><br><span class="line"><span class="comment"># stop on number:1 time--&gt; 1577155043.4311821</span></span><br><span class="line"><span class="comment"># stop on number:2 time--&gt; 1577155044.4308763</span></span><br></pre></td></tr></table></figure>

<h3 id="threading-thread的实例方法"><a href="#threading-thread的实例方法" class="headerlink" title="threading.thread的实例方法"></a>threading.thread的实例方法</h3><h4 id="join-和setDaemon"><a href="#join-和setDaemon" class="headerlink" title="join()和setDaemon()"></a>join()和setDaemon()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># join()：在子线程完成运行之前，这个子线程的父线程将一直被阻塞。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setDaemon(True)：</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">         将线程声明为守护线程，必须在start() 方法调用之前设置，如果不设置为守护线程程序会被无限挂起。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程 就分兵两路，分别运行，那么当主线程完成</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是只要主线程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以 用setDaemon方法啦'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime, sleep</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">music</span><span class="params">(name)</span>:</span></span><br><span class="line">        print(<span class="string">"Begin listening to &#123;name&#125;. &#123;time&#125;"</span>.format(name=name, time=ctime()))</span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        print(<span class="string">"end listening &#123;time&#125;"</span>.format(time=ctime()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blog</span><span class="params">(title)</span>:</span></span><br><span class="line">        print(<span class="string">"Begin recording the &#123;title&#125;. &#123;time&#125;"</span>.format(title=title, time=ctime()))</span><br><span class="line">        sleep(<span class="number">5</span>)</span><br><span class="line">        print(<span class="string">'end recording &#123;time&#125;'</span>.format(time=ctime()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">t1 = threading.Thread(target=music, args=(<span class="string">'过火'</span>,))  <span class="comment"># 生成线程实例</span></span><br><span class="line">t2 = threading.Thread(target=blog, args=(<span class="string">'博客园'</span>,))</span><br><span class="line">threads.append(t1)</span><br><span class="line">threads.append(t2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    print(<span class="string">"all over %s"</span> % ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Begin listening to 过火. Tue Dec 24 10:49:41 2019</span></span><br><span class="line"><span class="comment"># Begin recording the 博客园. Tue Dec 24 10:49:41 2019</span></span><br><span class="line"><span class="comment"># all over Tue Dec 24 10:49:41 2019</span></span><br><span class="line"><span class="comment"># end listening Tue Dec 24 10:49:44 2019</span></span><br><span class="line"><span class="comment"># end recording Tue Dec 24 10:49:46 2019</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()  <span class="comment"># 等待执行完毕</span></span><br><span class="line">    print(<span class="string">"all over %s"</span> % ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Begin listening to 过火. Tue Dec 24 10:52:43 2019</span></span><br><span class="line"><span class="comment"># end listening Tue Dec 24 10:52:46 2019</span></span><br><span class="line"><span class="comment"># Begin recording the 博客园. Tue Dec 24 10:52:46 2019</span></span><br><span class="line"><span class="comment"># end recording Tue Dec 24 10:52:51 2019</span></span><br><span class="line"><span class="comment"># all over Tue Dec 24 10:52:51 2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先听歌、再看博客、再结束</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    t1.join()  <span class="comment"># 等待执行完毕</span></span><br><span class="line">    print(<span class="string">"all over %s"</span> % ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Begin listening to 过火. Tue Dec 24 11:01:21 2019</span></span><br><span class="line"><span class="comment"># Begin recording the 博客园. Tue Dec 24 11:01:21 2019</span></span><br><span class="line"><span class="comment"># end listening Tue Dec 24 11:01:24 2019</span></span><br><span class="line"><span class="comment"># all over Tue Dec 24 11:01:24 2019</span></span><br><span class="line"><span class="comment"># end recording Tue Dec 24 11:01:26 2019</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    t2.join()  <span class="comment"># 等待执行完毕</span></span><br><span class="line">    print(<span class="string">"all over %s"</span> % ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Begin listening to 过火. Tue Dec 24 11:03:01 2019</span></span><br><span class="line"><span class="comment"># Begin recording the 博客园. Tue Dec 24 11:03:01 2019</span></span><br><span class="line"><span class="comment"># end listening Tue Dec 24 11:03:04 2019</span></span><br><span class="line"><span class="comment"># end recording Tue Dec 24 11:03:06 2019</span></span><br><span class="line"><span class="comment"># all over Tue Dec 24 11:03:06 2019</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.setDaemon(<span class="literal">True</span>)  <span class="comment"># 注意:一定在start之前设置</span></span><br><span class="line">        t.start()</span><br><span class="line">    print(<span class="string">"all over %s"</span> % ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Begin listening to 过火. Tue Dec 24 11:03:52 2019</span></span><br><span class="line"><span class="comment"># Begin recording the 博客园. Tue Dec 24 11:03:52 2019</span></span><br><span class="line"><span class="comment"># all over Tue Dec 24 11:03:52 2019</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)  <span class="comment"># 注意:一定在start之前设置</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    print(<span class="string">"all over %s"</span> % ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Begin listening to 过火. Tue Dec 24 11:05:57 2019</span></span><br><span class="line"><span class="comment"># Begin recording the 博客园. Tue Dec 24 11:05:57 2019</span></span><br><span class="line"><span class="comment"># all over Tue Dec 24 11:05:57 2019</span></span><br><span class="line"><span class="comment"># end listening Tue Dec 24 11:06:00 2019</span></span><br><span class="line"><span class="comment"># end recording Tue Dec 24 11:06:02 2019</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t2.setDaemon(<span class="literal">True</span>)  <span class="comment"># 注意:一定在start之前设置</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    print(<span class="string">"all over %s"</span> % ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Begin listening to 过火. Tue Dec 24 11:05:25 2019</span></span><br><span class="line"><span class="comment"># Begin recording the 博客园. Tue Dec 24 11:05:25 2019</span></span><br><span class="line"><span class="comment"># all over Tue Dec 24 11:05:25 2019</span></span><br><span class="line"><span class="comment"># end listening Tue Dec 24 11:05:28 2019</span></span><br></pre></td></tr></table></figure>

<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run():  线程被cpu调度后自动执行线程对象的run方法</span></span><br><span class="line"><span class="comment"># start():启动线程活动。</span></span><br><span class="line"><span class="comment"># isAlive(): 返回线程是否活动的。</span></span><br><span class="line"><span class="comment"># getName(): 返回线程名。</span></span><br><span class="line"><span class="comment"># setName(): 设置线程名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># threading模块提供的一些方法：</span></span><br><span class="line"><span class="comment"># threading.currentThread(): 返回当前的线程变量。</span></span><br><span class="line"><span class="comment"># threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span></span><br><span class="line"><span class="comment"># threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span></span><br></pre></td></tr></table></figure>

<h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 在每个线程中都获取这个全局变量</span></span><br><span class="line">    temp = num</span><br><span class="line">    <span class="comment"># print('--get num:', num)</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    num = temp<span class="number">-1</span>  <span class="comment"># 对此公共变量进行-1操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span>  <span class="comment"># 设定一个共享变量</span></span><br><span class="line">thread_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    t = threading.Thread(target=add_num)</span><br><span class="line">    t.start()</span><br><span class="line">    thread_list.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread_list:  <span class="comment"># 等待所有线程执行完毕</span></span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'final num:'</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># final num: 99</span></span><br></pre></td></tr></table></figure>

<p><strong>观察：time.sleep(0.1)  /0.001/0.0000001 结果分别是多少？</strong></p>
<p>多个线程都在同时操作同一个共享资源，所以造成了资源破坏，怎么办呢？(join会造成串行，失去所线程的意义)</p>
<p>我们可以通过<strong>同步锁</strong>来解决这种问题.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R=threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    R.acquire()</span><br><span class="line">    temp=num<span class="number">-1</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    num=temp</span><br><span class="line">    R.release()</span><br></pre></td></tr></table></figure>

<p>锁通常被用来实现对共享资源的同步访问。为每一个共享资源创建一个Lock对象，当你需要访问该资源时，调用acquire方法来获取锁对象（如果其它线程已经获得了该锁，则当前线程需等待其被释放），待资源访问完后，再调用release方法释放锁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">R=threading.Lock()</span><br><span class="line"></span><br><span class="line">R.acquire()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">对公共数据的操作</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">R.release()</span><br></pre></td></tr></table></figure>

<p>思考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1、为什么有了GIL，还需要线程同步？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多线程环境下必须存在资源的竞争,那么如何才能保证同一时刻只有一个线程对共享资源进行存取?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">加锁, 对, 加锁可以保证存取操作的唯一性, 从而保证同一时刻只有一个线程对共享数据存取.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通常加锁也有2种不同的粒度的锁:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    coarse-grained(粗粒度)： python解释器层面维护着一个全局的锁机制,用来保证线程安全。</span></span><br><span class="line"><span class="string">                            内核级通过GIL实现的互斥保护了内核的共享资源。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fine-grained(细粒度)：   那么程序员需要自行地加,解锁来保证线程安全，</span></span><br><span class="line"><span class="string">                            用户级通过自行加锁保护的用户程序的共享资源。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 2、GIL为什么限定在一个进程上？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 你写一个py程序，运行起来本身就是一个进程，这个进程是有解释器来翻译的，所以GIL限定在当前进程；</span></span><br><span class="line"><span class="string"> 如果又创建了一个子进程，那么两个进程是完全独立的，这个字进程也是有python解释器来运行的，所以</span></span><br><span class="line"><span class="string"> 这个子进程上也是受GIL影响的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="线程死锁和递归锁"><a href="#线程死锁和递归锁" class="headerlink" title="线程死锁和递归锁"></a>线程死锁和递归锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去。下面是一个死锁的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fun1()</span><br><span class="line">        self.fun2()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(self)</span>:</span></span><br><span class="line">        mutexA.acquire()  <span class="comment"># 如果锁被占用,则阻塞在这里,等待锁的释放</span></span><br><span class="line">        print(<span class="string">"I am %s , get res: %s---%s"</span> %(self.name, <span class="string">"ResA"</span>,time.time()))</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(<span class="string">"I am %s , get res: %s---%s"</span> %(self.name, <span class="string">"ResB"</span>,time.time()))</span><br><span class="line">        mutexB.release()</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(self)</span>:</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(<span class="string">"I am %s , get res: %s---%s"</span> %(self.name, <span class="string">"ResB"</span>,time.time()))</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(<span class="string">"I am %s , get res: %s---%s"</span> %(self.name, <span class="string">"ResA"</span>,time.time()))</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"start---------------------------%s"</span>%time.time())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        my_thread = MyThread()</span><br><span class="line">        my_thread.start()</span><br></pre></td></tr></table></figure>

<p>在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex = threading.RLock()</span><br><span class="line">mutexA = mutexB = mutex</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _id, balance)</span>:</span></span><br><span class="line">        self.id = _id</span><br><span class="line">        self.balance = balance</span><br><span class="line">        self.lock = threading.RLock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.balance -= amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.balance += amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drawcash</span><span class="params">(self, amount)</span>:</span><span class="comment">#lock.acquire中嵌套lock.acquire的场景</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            interest = <span class="number">0.05</span></span><br><span class="line">            count = amount+amount*interest</span><br><span class="line">            self.withdraw(count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(_from, to, amount)</span>:</span></span><br><span class="line">    <span class="comment"># 锁不可以加在这里 因为其他的其它线程执行的其它方法在不加锁的情况下数据同样是不安全的</span></span><br><span class="line">    _from.withdraw(amount)</span><br><span class="line">    to.deposit(amount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alex = Account(<span class="string">'alex'</span>, <span class="number">1000</span>)</span><br><span class="line">yuan = Account(<span class="string">'yuan'</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">t1=threading.Thread(target=transfer, args=(alex, yuan, <span class="number">100</span>))</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2=threading.Thread(target = transfer, args = (yuan,alex, <span class="number">200</span>))</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&gt;&gt;&gt;'</span>,alex.balance)</span><br><span class="line">print(<span class="string">'&gt;&gt;&gt;'</span>,yuan.balance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 1100</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 900</span></span><br></pre></td></tr></table></figure>

<h3 id="Event对象"><a href="#Event对象" class="headerlink" title="Event对象"></a>Event对象</h3><p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就 会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># event.isSet()：返回event的状态值；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># event.wait()：如果 event.isSet()==False将阻塞线程；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># event.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># event.clear()：恢复event的状态值为False。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"BOSS：今晚大家都要加班到22:00。"</span>)</span><br><span class="line">        print(event.isSet())</span><br><span class="line">        event.set()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        print(<span class="string">"BOSS：&lt;22:00&gt;可以下班了。"</span>)</span><br><span class="line">        print(event.isSet())</span><br><span class="line">        event.set()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        event.wait()</span><br><span class="line">        print(<span class="string">"Worker：哎……命苦啊！"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        event.clear()</span><br><span class="line">        event.wait()</span><br><span class="line">        print(<span class="string">"Worker：OhYeah!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        threads.append(Worker())</span><br><span class="line">    threads.append(Boss())</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># BOSS：今晚大家都要加班到22:00。</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># Worker：哎……命苦啊！</span></span><br><span class="line"><span class="comment"># Worker：哎……命苦啊！</span></span><br><span class="line"><span class="comment"># Worker：哎……命苦啊！</span></span><br><span class="line"><span class="comment"># Worker：哎……命苦啊！</span></span><br><span class="line"><span class="comment"># Worker：哎……命苦啊！</span></span><br><span class="line"><span class="comment"># BOSS：&lt;22:00&gt;可以下班了。</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># Worker：OhYeah!</span></span><br><span class="line"><span class="comment"># Worker：OhYeah!</span></span><br><span class="line"><span class="comment"># Worker：OhYeah!</span></span><br><span class="line"><span class="comment"># Worker：OhYeah!</span></span><br><span class="line"><span class="comment"># Worker：OhYeah!</span></span><br></pre></td></tr></table></figure>
<p>threading.Event的wait方法还接受一个超时参数，默认情况下如果事件一致没有发生，wait方法会一直阻塞下去，而加入这个超时参数之后，如果阻塞时间超过这个参数设定的值之后，wait方法会返回。</p>
<h3 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a>Semaphore（信号量）</h3><p>信号量用来控制线程并发数的，BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。<br>计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。(类似于停车位的概念)<br>BoundedSemaphore与Semaphore的唯一区别在于前者将在调用release()时检查计数 器的值是否超过了计数器的初始值，如果超过了将抛出一个异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">semaphore = threading.Semaphore(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> semaphore.acquire():</span><br><span class="line">        <span class="keyword">print</span> (threading.currentThread().getName() + <span class="string">' get semaphore'</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        semaphore.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">  t1 = threading.Thread(target=func)</span><br><span class="line">  t1.start()</span><br></pre></td></tr></table></figure>

<p>应用：连接池</p>
<p>思考：与Rlock的区别？</p>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p><strong>为什么要使用生产者和消费者模式</strong><br>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。<br><strong>什么是生产者消费者模式</strong><br>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>这就像，在餐厅，厨师做好菜，不需要直接和客户交流，而是交给前台，而客户去饭菜也不需要不找厨师，直接去前台领取即可，这也是一个结耦的过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time,random</span><br><span class="line"><span class="keyword">import</span> queue,threading</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Producer</span><span class="params">(name)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> count &lt;<span class="number">10</span>:</span><br><span class="line">    print(<span class="string">"making........"</span>)</span><br><span class="line">    time.sleep(random.randrange(<span class="number">3</span>))</span><br><span class="line">    q.put(count)</span><br><span class="line">    print(<span class="string">'Producer %s has produced %s baozi..'</span> %(name, count))</span><br><span class="line">    count +=<span class="number">1</span></span><br><span class="line">    <span class="comment">#q.task_done()</span></span><br><span class="line">    <span class="comment">#q.join()</span></span><br><span class="line">    print(<span class="string">"ok......"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> count &lt;<span class="number">10</span>:</span><br><span class="line">    time.sleep(random.randrange(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        data = q.get()</span><br><span class="line">        <span class="comment">#q.task_done()</span></span><br><span class="line">        <span class="comment">#q.join()</span></span><br><span class="line">        print(data)</span><br><span class="line">        print(<span class="string">'\033[32;1mConsumer %s has eat %s baozi...\033[0m'</span> %(name, data))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"-----no baozi anymore----"</span>)</span><br><span class="line">    count +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">p1 = threading.Thread(target=Producer, args=(<span class="string">'A'</span>,))</span><br><span class="line">c1 = threading.Thread(target=Consumer, args=(<span class="string">'B'</span>,))</span><br><span class="line"><span class="comment"># c2 = threading.Thread(target=Consumer, args=('C',))</span></span><br><span class="line"><span class="comment"># c3 = threading.Thread(target=Consumer, args=('D',))</span></span><br><span class="line">p1.start()</span><br><span class="line">c1.start()</span><br><span class="line"><span class="comment"># c2.start()</span></span><br><span class="line"><span class="comment"># c3.start()</span></span><br></pre></td></tr></table></figure>

<h2 id="多进程模块-multiprocessing"><a href="#多进程模块-multiprocessing" class="headerlink" title="多进程模块 multiprocessing"></a>多进程模块 multiprocessing</h2><p>multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。</p>
<h3 id="python的进程调用"><a href="#python的进程调用" class="headerlink" title="python的进程调用"></a>python的进程调用</h3><p>直接调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name, time.ctime())</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p = Process(target=f, args=(<span class="string">'alvin:%s'</span> % i,))</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">        p.join()</span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># hello alvin:0 Tue Dec 24 13:58:18 2019</span></span><br><span class="line"><span class="comment"># hello alvin:1 Tue Dec 24 13:58:18 2019</span></span><br><span class="line"><span class="comment"># hello alvin:2 Tue Dec 24 13:58:18 2019</span></span><br><span class="line"><span class="comment"># end</span></span><br></pre></td></tr></table></figure>

<p>继承调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyProcess, self).__init__()</span><br><span class="line">        <span class="comment"># self.name = name</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'hello'</span>, self.name, time.ctime())</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p = MyProcess()</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">        p.join()</span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># hello MyProcess-1 Tue Dec 24 14:01:52 2019</span></span><br><span class="line"><span class="comment"># hello MyProcess-2 Tue Dec 24 14:01:52 2019</span></span><br><span class="line"><span class="comment"># hello MyProcess-3 Tue Dec 24 14:01:52 2019</span></span><br><span class="line"><span class="comment"># end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造方法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process([group [, target [, name [, args [, kwargs]]]]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 　　group: 线程组，目前还没有实现，库引用中提示必须是None；</span></span><br><span class="line"><span class="comment"># 　　target: 要执行的方法；</span></span><br><span class="line"><span class="comment"># 　　name: 进程名；</span></span><br><span class="line"><span class="comment"># 　　args/kwargs: 要传入方法的参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例方法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 　　is_alive()：返回进程是否在运行。</span></span><br><span class="line"><span class="comment"># 　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。</span></span><br><span class="line"><span class="comment"># 　　start()：进程准备就绪，等待CPU调度</span></span><br><span class="line"><span class="comment"># 　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。</span></span><br><span class="line"><span class="comment"># 　　terminate()：不管任务是否完成，立即停止工作进程</span></span><br><span class="line"><span class="comment"># 属性：</span></span><br><span class="line"><span class="comment"># 　　daemon：和线程的setDeamon功能一样</span></span><br><span class="line"><span class="comment"># 　　name：进程名字。</span></span><br><span class="line"><span class="comment"># 　　pid：进程号。</span></span><br></pre></td></tr></table></figure>

<h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><h4 id="进程队列Queue"><a href="#进程队列Queue" class="headerlink" title="进程队列Queue"></a>进程队列Queue</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q, n)</span>:</span></span><br><span class="line">    q.put(n*n+<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"son process"</span>, id(q))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    print(<span class="string">"main process"</span>, id(q))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p = Process(target=f, args=(q, i))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    print(q.get())</span><br><span class="line">    print(q.get())</span><br><span class="line">    print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># main process 1774500620384</span></span><br><span class="line"><span class="comment"># son process 1894343054952</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># son process 1229893801576</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># son process 1879186937336</span></span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>Pipe（）返回的两个连接对象代表管道的两端。 每个连接对象都有send()和recv()方法（等等）。 请注意，如果两个进程（或线程）尝试同时读取或写入管道的同一端，管道中的数据可能会损坏。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">12</span>, &#123;<span class="string">"name"</span>: <span class="string">"yuan"</span>&#125;, <span class="string">'hello'</span>])</span><br><span class="line">    response = conn.recv()</span><br><span class="line">    print(<span class="string">"response"</span>, response)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line">    print(<span class="string">"p_ID:"</span>, id(parent_conn), <span class="string">"q_ID1:"</span>, id(child_conn))</span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())</span><br><span class="line">    parent_conn.send(<span class="string">"儿子你好!"</span>)</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># p_ID: 1559578636640 q_ID1: 1559578637368</span></span><br><span class="line"><span class="comment"># [12, &#123;'name': 'yuan'&#125;, 'hello']</span></span><br><span class="line"><span class="comment"># response 儿子你好!</span></span><br></pre></td></tr></table></figure>

<h4 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h4><p>Queue和pipe只是实现了数据交互，并没实现数据共享，即一个进程去更改另一个进程的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d, l, n)</span>:</span></span><br><span class="line">    d[n] = n</span><br><span class="line">    d[<span class="string">"name"</span>] =<span class="string">"alvin"</span></span><br><span class="line">    l.append(n)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"进程："</span>, n, <span class="string">"列表L:"</span>,l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Manager() <span class="keyword">as</span> manager:</span><br><span class="line">        d = manager.dict()</span><br><span class="line">        l = manager.list(range(<span class="number">5</span>))</span><br><span class="line">        p_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            p = Process(target=f, args=(d,l,i))</span><br><span class="line">            p.start()</span><br><span class="line">            p_list.append(p)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> res <span class="keyword">in</span> p_list:</span><br><span class="line">            res.join()</span><br><span class="line"></span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 进程： 2 列表L: [0, 1, 2, 3, 4, 2]</span></span><br><span class="line"><span class="comment"># 进程： 5 列表L: [0, 1, 2, 3, 4, 2, 5]</span></span><br><span class="line"><span class="comment"># 进程： 7 列表L: [0, 1, 2, 3, 4, 2, 5, 7]</span></span><br><span class="line"><span class="comment"># 进程： 3 列表L: [0, 1, 2, 3, 4, 2, 5, 7, 3]</span></span><br><span class="line"><span class="comment"># 进程： 9 列表L: [0, 1, 2, 3, 4, 2, 5, 7, 3, 9]</span></span><br><span class="line"><span class="comment"># 进程： 6 列表L: [0, 1, 2, 3, 4, 2, 5, 7, 3, 9, 6]</span></span><br><span class="line"><span class="comment"># 进程： 4 列表L: [0, 1, 2, 3, 4, 2, 5, 7, 3, 9, 6, 4]</span></span><br><span class="line"><span class="comment"># 进程： 8 列表L: [0, 1, 2, 3, 4, 2, 5, 7, 3, 9, 6, 4, 8]</span></span><br><span class="line"><span class="comment"># 进程： 0 列表L: [0, 1, 2, 3, 4, 2, 5, 7, 3, 9, 6, 4, 8, 0]</span></span><br><span class="line"><span class="comment"># 进程： 1 列表L: [0, 1, 2, 3, 4, 2, 5, 7, 3, 9, 6, 4, 8, 0, 1]</span></span><br><span class="line"><span class="comment"># &#123;2: 2, 'name': 'alvin', 5: 5, 7: 7, 3: 3, 9: 9, 6: 6, 4: 4, 8: 8, 0: 0, 1: 1&#125;</span></span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 2, 5, 7, 3, 9, 6, 4, 8, 0, 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(l, i)</span>:</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">with</span> l.acquire():</span><br><span class="line">        print(<span class="string">'hello world %s'</span>%i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Process(target=f, args=(lock, num)).start()</span><br></pre></td></tr></table></figure>

<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(args)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p.apply_async(func=foo, args=(i,))</span><br><span class="line"></span><br><span class="line">    p.close()   <span class="comment"># 等子进程执行完毕后关闭线程池</span></span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    <span class="comment"># p.terminate()  # 立刻关闭线程池</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p>进程池内部维护一个进程序列，当使用时，去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<p>进程池中有以下几个主要方法：</p>
<p>apply：从进程池里取一个进程并执行<br>apply_async：apply的异步版本<br>terminate:立刻关闭线程池<br>join：主进程等待所有子进程执行完毕，必须在close或terminate之后<br>close：等待所有进程结束后，才关闭线程池  </p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是协程：协程是一种用户态的轻量级线程。</p>
<p><strong>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。</strong>因此：</p>
<p><strong>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</strong></p>
<h3 id="yield与协程"><a href="#yield与协程" class="headerlink" title="yield与协程"></a>yield与协程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</span></span><br><span class="line"><span class="string">如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 注意到consumer函数是一个generator（生成器）:</span></span><br><span class="line"><span class="comment"># 任何包含yield关键字的函数都会自动成为生成器(generator)对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 3、consumer通过yield拿到消息，处理，又通过yield把结果传回；</span></span><br><span class="line">        <span class="comment">#    yield指令具有return关键字的作用。然后函数的堆栈会自动冻结(freeze)在这一行。</span></span><br><span class="line">        <span class="comment">#    当函数调用者的下一次利用next()或generator.send()或for-in来再次调用该函数时，</span></span><br><span class="line">        <span class="comment">#    就会从yield代码的下一行开始，继续执行，再返回下一次迭代结果。通过这种方式，迭代器可以实现无限序列和惰性求值。</span></span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] ←← Consuming %s...'</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="comment"># 1、首先调用c.next()启动生成器</span></span><br><span class="line">    next(c)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] →→ Producing %s...'</span> % n)</span><br><span class="line">        <span class="comment"># 2、然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</span></span><br><span class="line">        cr = c.send(n)</span><br><span class="line">        <span class="comment"># 4、produce拿到consumer处理的结果，继续生产下一条消息；</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % cr)</span><br><span class="line">    <span class="comment"># 5、produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</span></span><br><span class="line">    c.close()</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 6、整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</span></span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">result:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[PRODUCER] →→ Producing 1...</span></span><br><span class="line"><span class="string">[CONSUMER] ←← Consuming 1...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] →→ Producing 2...</span></span><br><span class="line"><span class="string">[CONSUMER] ←← Consuming 2...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] →→ Producing 3...</span></span><br><span class="line"><span class="string">[CONSUMER] ←← Consuming 3...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] →→ Producing 4...</span></span><br><span class="line"><span class="string">[CONSUMER] ←← Consuming 4...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">[PRODUCER] →→ Producing 5...</span></span><br><span class="line"><span class="string">[CONSUMER] ←← Consuming 5...</span></span><br><span class="line"><span class="string">[PRODUCER] Consumer return: 200 OK</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h3><p>greenlet机制的主要思想是：生成器函数或者协程函数中的yield语句挂起函数的执行，直到稍后使用next()或send()操作进行恢复为止。可以使用一个调度器循环在一组生成器函数之间协作多个任务。greentlet是python中实现我们所谓的”Coroutine(协程)”的一个基础库.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="number">12</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    <span class="keyword">print</span> (<span class="number">34</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="number">56</span>)</span><br><span class="line">    gr1.switch()</span><br><span class="line">    <span class="keyword">print</span> (<span class="number">78</span>)</span><br><span class="line"></span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># 56</span></span><br><span class="line"><span class="comment"># 34</span></span><br><span class="line"><span class="comment"># 78</span></span><br></pre></td></tr></table></figure>

<h3 id="基于greenlet的框架–gevent模块实现协程"><a href="#基于greenlet的框架–gevent模块实现协程" class="headerlink" title="基于greenlet的框架–gevent模块实现协程"></a>基于greenlet的框架–gevent模块实现协程</h3><p>Python通过yield提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。<br>gevent是第三方库，通过greenlet实现协程，其基本思想是：<br>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。<br>由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey patch完成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running in foo"</span>)</span><br><span class="line">    gevent.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"switch to foo again"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"switch to bar"</span>)</span><br><span class="line">    gevent.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"switch to bar again"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">gevent.joinall(</span><br><span class="line">    [gevent.spawn(foo), gevent.spawn(bar)]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(time.time()-start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># running in foo</span></span><br><span class="line"><span class="comment"># switch to bar</span></span><br><span class="line"><span class="comment"># switch to foo again</span></span><br><span class="line"><span class="comment"># switch to bar again</span></span><br><span class="line"><span class="comment"># 5.0048134326934814</span></span><br></pre></td></tr></table></figure>

<p>当然，实际代码里，我们不会用gevent.sleep()去切换协程，而是在执行到IO操作时，gevent自动切换，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'GET: %s'</span> % url)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    resp = request.urlopen(url)</span><br><span class="line">    data = resp.read()</span><br><span class="line">    print(<span class="string">'%d bytes received from %s. time: %s'</span> % (len(data), url, time.time() - start_time))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://itk.org/'</span>),</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://www.baidu.com/'</span>),</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://zhihu.com/'</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----'</span>)</span><br><span class="line">f(<span class="string">'https://itk.org/'</span>)</span><br><span class="line">f(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">f(<span class="string">'https://zhihu.com/'</span>)</span><br><span class="line"></span><br><span class="line">print(time.time()-start)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># GET: https://itk.org/</span></span><br><span class="line"><span class="comment"># GET: https://www.baidu.com/</span></span><br><span class="line"><span class="comment"># GET: https://zhihu.com/</span></span><br><span class="line"><span class="comment"># 227 bytes received from https://www.baidu.com/. time: 0.14103436470031738</span></span><br><span class="line"><span class="comment"># 46368 bytes received from https://zhihu.com/. time: 0.7752258777618408</span></span><br><span class="line"><span class="comment"># 27383 bytes received from https://itk.org/. time: 3.584683895111084</span></span><br><span class="line"><span class="comment"># -----</span></span><br><span class="line"><span class="comment"># GET: https://itk.org/</span></span><br><span class="line"><span class="comment"># 27383 bytes received from https://itk.org/. time: 2.513073682785034</span></span><br><span class="line"><span class="comment"># GET: https://www.baidu.com/</span></span><br><span class="line"><span class="comment"># 227 bytes received from https://www.baidu.com/. time: 0.13568687438964844</span></span><br><span class="line"><span class="comment"># GET: https://zhihu.com/</span></span><br><span class="line"><span class="comment"># 46368 bytes received from https://zhihu.com/. time: 0.815751314163208</span></span><br><span class="line"><span class="comment"># 7.051190376281738</span></span><br></pre></td></tr></table></figure>

<h3 id="协程的好处"><a href="#协程的好处" class="headerlink" title="协程的好处"></a>协程的好处</h3><p>无需线程上下文切换的开销<br>无需原子操作锁定及同步的开销<br>方便切换控制流，简化编程模型<br>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。<br>缺点：<br>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。<br>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序.  </p>
<p>– end –</p>

    </div>

    
    
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="LoneyCao 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="LoneyCao 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>LoneyCao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://loney-cao.github.io/2019/12/23/python_10/" title="Python-- 进程、线程、协程">http://loney-cao.github.io/2019/12/23/python_10/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/12/23/python_9/" rel="next" title="Python-- websocket实现">
                  <i class="fa fa-chevron-left"></i> Python-- websocket实现
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/12/23/tools_1/" rel="prev" title="工具类-- Chrome贱兮兮的报错：“喔唷，崩溃啦！”">
                  工具类-- Chrome贱兮兮的报错：“喔唷，崩溃啦！” <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
      
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引子"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程定义"><span class="nav-number">2.</span> <span class="nav-text">进程定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">3.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程进程的关系区别"><span class="nav-number">4.</span> <span class="nav-text">线程进程的关系区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-的-GIL"><span class="nav-number">5.</span> <span class="nav-text">Python 的 GIL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python的线程与threading模块"><span class="nav-number">6.</span> <span class="nav-text">python的线程与threading模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的两种调用方式"><span class="nav-number">6.1.</span> <span class="nav-text">线程的两种调用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#threading-thread的实例方法"><span class="nav-number">6.2.</span> <span class="nav-text">threading.thread的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#join-和setDaemon"><span class="nav-number">6.2.1.</span> <span class="nav-text">join()和setDaemon()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它方法"><span class="nav-number">6.2.2.</span> <span class="nav-text">其它方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步锁"><span class="nav-number">6.3.</span> <span class="nav-text">同步锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程死锁和递归锁"><span class="nav-number">6.4.</span> <span class="nav-text">线程死锁和递归锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event对象"><span class="nav-number">6.5.</span> <span class="nav-text">Event对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore（信号量）"><span class="nav-number">6.6.</span> <span class="nav-text">Semaphore（信号量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者模型"><span class="nav-number">6.7.</span> <span class="nav-text">生产者消费者模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多进程模块-multiprocessing"><span class="nav-number">7.</span> <span class="nav-text">多进程模块 multiprocessing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#python的进程调用"><span class="nav-number">7.1.</span> <span class="nav-text">python的进程调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通讯"><span class="nav-number">7.2.</span> <span class="nav-text">进程间通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程队列Queue"><span class="nav-number">7.2.1.</span> <span class="nav-text">进程队列Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道"><span class="nav-number">7.2.2.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#manager"><span class="nav-number">7.2.3.</span> <span class="nav-text">manager</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程同步"><span class="nav-number">7.3.</span> <span class="nav-text">进程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程池"><span class="nav-number">7.4.</span> <span class="nav-text">进程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程"><span class="nav-number">8.</span> <span class="nav-text">协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#yield与协程"><span class="nav-number">8.1.</span> <span class="nav-text">yield与协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#greenlet"><span class="nav-number">8.2.</span> <span class="nav-text">greenlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于greenlet的框架–gevent模块实现协程"><span class="nav-number">8.3.</span> <span class="nav-text">基于greenlet的框架–gevent模块实现协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程的好处"><span class="nav-number">8.4.</span> <span class="nav-text">协程的好处</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="LoneyCao"
    src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">LoneyCao</p>
  <div class="site-description" itemprop="description">专注Odoo知识领域</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Loney-Cao" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Loney-Cao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/dd4c87138bc0" title="简书 &amp;rarr; https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;dd4c87138bc0" rel="noopener" target="_blank"><i class="fa fa-fw fa-jianshu"></i>简书</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LoneyCao</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  

  

<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: true,
    appId: 'JB8FpvK5rrCA4RqQfnpxGgiQ-gzGzoHsz',
    appKey: 'cU9FMU8iuV4LzSjG2QU0OUF6',
    placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

    </div>

  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  <script type="text/javascript" src="/js/src/mouse-click.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
</body>
</html>
